<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.youis.top</id>
    <title>Eden的博客</title>
    <updated>2020-04-26T01:32:05.401Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.youis.top"/>
    <link rel="self" href="https://blog.youis.top/atom.xml"/>
    <subtitle>浮生若梦，人生几何</subtitle>
    <logo>https://blog.youis.top/images/avatar.png</logo>
    <icon>https://blog.youis.top/favicon.ico</icon>
    <rights>All rights reserved 2020, Eden的博客</rights>
    <entry>
        <title type="html"><![CDATA[docker安装kafka]]></title>
        <id>https://blog.youis.top/post/NKkoP0wN4/</id>
        <link href="https://blog.youis.top/post/NKkoP0wN4/">
        </link>
        <updated>2020-04-25T08:21:56.000Z</updated>
        <summary type="html"><![CDATA[<p>docker妈耶，真香😁😁😁😁</p>
<h1 id="安装zookeeper">安装zookeeper</h1>
<p>kafka需要zookeeper管理，所以需要先安装zookeeper。<br>
下载zookeeper镜像<br>
$ docker pull zookeeper</p>
]]></summary>
        <content type="html"><![CDATA[<p>docker妈耶，真香😁😁😁😁</p>
<h1 id="安装zookeeper">安装zookeeper</h1>
<p>kafka需要zookeeper管理，所以需要先安装zookeeper。<br>
下载zookeeper镜像<br>
$ docker pull zookeeper</p>
<!-- more -->
<h2 id="启动镜像生成容器">启动镜像生成容器</h2>
<pre><code class="language-shell">docker run -d --restart=always --log-driver json-file --log-opt max-size=100m --log-opt max-file=2  --name zookeeper -p 2181:2181 -v /etc/localtime:/etc/localtime wurstmeister/zookeeper
</code></pre>
<h1 id="下载kafka镜像">下载kafka镜像</h1>
<pre><code class="language-shell">docker pull wurstmeister/kafka
</code></pre>
<p>4、启动kafka镜像生成容器</p>
<pre><code class="language-shell">docker run -d --restart=always --log-driver json-file --log-opt max-size=100m --log-opt max-file=2 --name kafka -p 9092:9092 -e KAFKA_BROKER_ID=0 -e KAFKA_ZOOKEEPER_CONNECT=172.16.0.13:2181/kafka -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://172.16.0.13:9092 -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 -v /etc/localtime:/etc/localtime wurstmeister/kafka
</code></pre>
<p>参数说明：<br>
-e KAFKA_BROKER_ID=0  在kafka集群中，每个kafka都有一个BROKER_ID来区分自己</p>
<p>-e KAFKA_ZOOKEEPER_CONNECT=172.16.0.13:2181/kafka 配置zookeeper管理kafka的路径172.16.0.13:2181/kafka</p>
<p>-e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://172.16.0.13:9092  把kafka的地址端口注册给zookeeper，如果是远程访问要改成外网IP,类如Java程序访问出现无法连接。</p>
<p>-e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 配置kafka的监听端口</p>
<p>-v /etc/localtime:/etc/localtime 容器时间同步虚拟机的时间</p>
<p>5、验证kafka是否可以使用</p>
<p>5.1、进入容器<br>
$ docker exec -it kafka bash</p>
<p>5.2、进入 /opt/kafka_2.12-2.3.0/bin/ 目录下<br>
$ cd /opt/kafka_2.12-2.3.0/bin/</p>
<p>5.3、运行kafka生产者发送消息<br>
$ ./kafka-console-producer.sh --broker-list localhost:9092 --topic sun</p>
<p>发送消息</p>
<pre><code>{&quot;datas&quot;:[{&quot;channel&quot;:&quot;&quot;,&quot;metric&quot;:&quot;temperature&quot;,&quot;producer&quot;:&quot;ijinus&quot;,&quot;sn&quot;:&quot;IJA0101-00002245&quot;,&quot;time&quot;:&quot;1543207156000&quot;,&quot;value&quot;:&quot;80&quot;}],&quot;ver&quot;:&quot;1.0&quot;}
</code></pre>
<p>5.4、运行kafka消费者接收消息<br>
$ ./kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic sun --from-beginning</p>
<p>👉👉<a href="https://www.cnblogs.com/linjiqin/p/11891776.html">参考文章</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[又拍云使用]]></title>
        <id>https://blog.youis.top/post/iobZKkOLk/</id>
        <link href="https://blog.youis.top/post/iobZKkOLk/">
        </link>
        <updated>2020-04-24T06:32:56.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>七牛云的cdn加速，使用https的话，要收费，没有免费流量。😒😒😒</p>
<p><a href="https://console.upyun.com/register/?invite=ryOpVZxtL">又拍云注册连接</a></p>
<p>直接上图</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>七牛云的cdn加速，使用https的话，要收费，没有免费流量。😒😒😒</p>
<p><a href="https://console.upyun.com/register/?invite=ryOpVZxtL">又拍云注册连接</a></p>
<p>直接上图</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://image.youis.top/20200424142140.png" alt="" loading="lazy"></figure>
<p>香不香，15G的流量。还可以https 😍😍😍</p>
<figure data-type="image" tabindex="2"><img src="https://image.youis.top/20200424142927.png" alt="" loading="lazy"></figure>
<p>有一点就是，添加logo的时候，是点击图片，就可以访问官网。</p>
<p>参考代码：</p>
<pre><code class="language-html">&lt;a href=&quot;https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral&quot;&gt;&lt;img src=&quot;https://www.z4a.net/images/2020/04/20/_logo5.png&quot; alt=&quot;_logo5.png&quot; border=&quot;0&quot; width=&quot;100&quot; height=&quot;20&quot; /&gt;&lt;/a&gt;
</code></pre>
<h1 id="如何开启https">如何开启HTTPS</h1>
<p>创建服务后，点击https，点击管理。添加证书即可，在又拍云购买的免费证书，需要几分钟认证。</p>
<figure data-type="image" tabindex="3"><img src="https://image.youis.top/20200424142517.png" alt="" loading="lazy"></figure>
<p>其他使用还是和七牛云差不多的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python第四次作业]]></title>
        <id>https://blog.youis.top/post/sRdAP2jaU/</id>
        <link href="https://blog.youis.top/post/sRdAP2jaU/">
        </link>
        <updated>2020-04-22T01:54:31.000Z</updated>
        <summary type="html"><![CDATA[<p>每节课都有作业。。。。。<br>
还有一个作业是上次布置过的。🙃🙃🙃</p>
]]></summary>
        <content type="html"><![CDATA[<p>每节课都有作业。。。。。<br>
还有一个作业是上次布置过的。🙃🙃🙃</p>
<!-- more -->
<p>1、首先生成包含1000个随机字符的字符串，然后统计每个字符的出现次数。<br>
参考string字符串模块的元组：</p>
<pre><code>import string
import random

x = string.ascii_letters + string.digits + string.punctuation
# print(x)
y = [random.choice(x) for i in range(1000)]  # 生成包含1000个随机字符的字符串
# print(y)
dic = dict()  # 使用字典保存每个字符出现次数
for ch in y:
    dic[ch] = dic.get(ch, 0) + 1  # d.get(ch,0) 返回ch出现的次数，若没有返回0
print(dic)
# nums = 0
# for values in dic.values():
#     nums += values
# print(nums)
</code></pre>
<p>2、写代码：有如下字典<br>
按照要求实现每一个功能</p>
<pre><code>dic = {&quot;k1&quot;: &quot;v1&quot;, &quot;k2&quot;: &quot;v2&quot;, &quot;k3&quot;: &quot;v3&quot;}

# 1、请循环遍历出所有的key
for key in dic:
    print(key)
# 2、请循环遍历出所有的value
for value in dic.values():
    print(value)
# 3、请循环遍历出所有的key和value
for key, value in dic.items():
    print(key, value)
# 4、请在字典中增加一个键值对,&quot;k4&quot;:&quot;v4&quot;，输出添加后的字典
dic[&quot;k4&quot;] = &quot;v4&quot;
print(dic)
# 5、请删除字典中键值对&quot;k1&quot;:&quot;v1&quot;,并输出删除后的结果
dic.pop(&quot;k1&quot;)
print(dic)
# 6、请删除字典中键&quot;k5&quot;对应的键值对，如果字典中不存在键&quot;k5&quot;,则不报错，返回None
print(dic.pop(&quot;k5&quot;, None))
# 7、请获取字典中&quot;k2&quot;对应的值
print(dic[&quot;k2&quot;])
# 8、请获取字典中&quot;k6&quot;对应的值,如果不存在，则不报错，并且让其返回None。
print(dic.get(&quot;k6&quot;))
# 9、现有dict2 = {&quot;k1&quot;:&quot;v11&quot;,&quot;a&quot;:&quot;b&quot;},通过一行操作使dict2 = {&quot;k1&quot;:&quot;v1&quot;,&quot;k2&quot;:&quot;v2&quot;,&quot;k3&quot;:&quot;v3&quot;,&quot;a&quot;:&quot;b&quot;}
dict1 = {&quot;k1&quot;: &quot;v1&quot;, &quot;k2&quot;: &quot;v2&quot;, &quot;k3&quot;: &quot;v3&quot;}
dict2 = {&quot;k1&quot;: &quot;v11&quot;, &quot;a&quot;: &quot;b&quot;}
dict2.update(dict1)
print(dict2)
</code></pre>
<p>3、组合嵌套题。写代码，有如下列表，按照要求实现每一个功能</p>
<pre><code># 10、组合嵌套题。写代码，有如下列表，按照要求实现每一个功能
lis = [[&quot;k&quot;, [&quot;qwe&quot;, 20, {&quot;k1&quot;: [&quot;tt&quot;, 3, &quot;1&quot;]}, 89], &quot;ab&quot;]]
# 10.1、将列表中的字符串“tt”变成字符串&quot;TT&quot;(用两种方法)
#  方法一：
lis[0][1][2][&quot;k1&quot;][0] = &quot;TT&quot;
print(lis)
#  方法二：
lis[0][1][2].get(&quot;k1&quot;)[0] = &quot;TT&quot;
print(lis)
# 10.2、将列表中的字符串&quot;1&quot;变成数字101(用两种方法)
lis[0][1][2][&quot;k1&quot;][2] = 101
print(lis)
#  方法二：
lis[0][1][2].get(&quot;k1&quot;)[2] = 101
print(lis)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python爬虫抓包工具]]></title>
        <id>https://blog.youis.top/post/iumJPhy8A/</id>
        <link href="https://blog.youis.top/post/iumJPhy8A/">
        </link>
        <updated>2020-04-21T06:19:52.000Z</updated>
        <summary type="html"><![CDATA[<p>爬虫的基本原理就是模拟客户端（可以是浏览器，也有可能是APP）向远程服务器发送 HTTP 请求，我们需要知道目标服务器的 HOST、URI、请求方法、请求参数、请求头、请求体。Web 网站通过 Chrome 浏览器可以找到这些信息。但是对于 APP 爬虫，就显得有些束手无策。这时候必须借用一些抓包工具来辅助我们分析APP背后的秘密。</p>
]]></summary>
        <content type="html"><![CDATA[<p>爬虫的基本原理就是模拟客户端（可以是浏览器，也有可能是APP）向远程服务器发送 HTTP 请求，我们需要知道目标服务器的 HOST、URI、请求方法、请求参数、请求头、请求体。Web 网站通过 Chrome 浏览器可以找到这些信息。但是对于 APP 爬虫，就显得有些束手无策。这时候必须借用一些抓包工具来辅助我们分析APP背后的秘密。</p>
<!-- more -->
<p>今天推荐4个HTTP代理工具通过抓包分析，帮助你还原APP背后的每个请求。</p>
<h1 id="fiddler">Fiddler</h1>
<p>Fiddler 是 Windows 平台最好用的可视化抓包工具，也是大家最熟知的 HTTP 代理工具，功能非常强大，除了可以清晰的了解每个请求与响应之外，还可以进行断点设置，修改请求数据、拦截响应内容。</p>
<p>此外，还可以自定义规则，通过修改脚本，加入自己的特殊处理，不过因为它是 C# 编写的，如果你要写复杂的脚本，需要懂C#。</p>
<p>过滤器功能使得你可以通过正则表达式规则将你关心的请求显示出来，如果你只需要抓特定网站的数据，这个功能就显得非常有用，可以去除很多干扰信息。</p>
<h1 id="charles">Charles</h1>
<p>Charles 是 macOS 平台下最好用的抓包分析工具之一，同样提供GUI界面，界面简洁，基本功能包括HTTP、HTTPS 请求抓包，支持请求参数的修改，最新的 Charles 4 还支持 HTTP/2。当然，也同时支持Windows 和 Linux， 不过这款工具是要收费的，免费试用 30 天，试用期过后功能受限。</p>
<h1 id="anyproxy">AnyProxy</h1>
<p>AnyProxy 是 阿里巴巴开源的 HTTP 抓包工具，基于 NodeJS 实现，优点是支持二次开发，可自定义请求处理逻辑，如果你会写JS的话，同时需要做一些自定义的处理，那么AnyProxy 是非常适合的。支持 HTTPS，提供了GUI界面。 GitHub地址：https://github.com/alibaba/anyproxy</p>
<h1 id="mitmproxy">mitmproxy</h1>
<p>mitmproxy 是一款基于 Python，支持 SSL 的抓包工具，用 Python 写爬虫的一定会很喜欢，因为他不仅是跨平台的，而且提供的是命令行交互模式，很有极（zhuang）客（bi）感。mitmproxy 包含 3 款工具：</p>
<p>mitmproxy: 带交互的终端界面<br>
mitmdump: mitmproxy 的命令行版本，类似于 tcpdump<br>
libmproxy: 用于 mitmproxy/mitmdump 的库<br>
GitHub 地址：https://github.com/mitmproxy/mitmproxy</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python第三次作业]]></title>
        <id>https://blog.youis.top/post/python-di-san-ci-zuo-ye/</id>
        <link href="https://blog.youis.top/post/python-di-san-ci-zuo-ye/">
        </link>
        <updated>2020-04-18T08:59:47.000Z</updated>
        <summary type="html"><![CDATA[<p>1.现有商品列表如下：</p>
<p>products =   [[&quot;iphone&quot;,6888],[&quot;MacPro&quot;,14800],[&quot;小米6&quot;,2499],[&quot;Coffee&quot;,31],[&quot;Book&quot;,60],[&quot;Nike&quot;,699]]，</p>
]]></summary>
        <content type="html"><![CDATA[<p>1.现有商品列表如下：</p>
<p>products =   [[&quot;iphone&quot;,6888],[&quot;MacPro&quot;,14800],[&quot;小米6&quot;,2499],[&quot;Coffee&quot;,31],[&quot;Book&quot;,60],[&quot;Nike&quot;,699]]，</p>
<!-- more -->
<p>需打印出以下格式：<br>
------商品列表------<br>
0 iphone 6888<br>
1 MacPro 14800<br>
2 小米6 2499<br>
3 Coffee 31<br>
4 Book 60<br>
5 Nike 699、</p>
<pre><code class="language-python"># encoding: utf-8
products = [[&quot;iphone&quot;, 6888], [&quot;MacPro&quot;, 14800], [&quot;小米6&quot;, 2499], [&quot;Coffee&quot;, 31], [&quot;Book&quot;, 60], [&quot;Nike&quot;, 699]]
print(&quot;------商品列表------&quot;)
for index, info in enumerate(products):
    print(index, info[0], info[1])
</code></pre>
<ol start="2">
<li>python 用户在键盘上输入一个自然数n，然后在区间[1, 5n]上随机生成n个不重复的自然数，输出这些自然数， 然后继续编写代码对这些自然数进行处理，只保留所有偶数，并输出这些偶数</li>
</ol>
<pre><code class="language-python">import random
n = int(input(&quot;请输入一个自然数N: &quot;))
numList = random.sample(range(1, 5 * n + 1), n)
print(numList)
outList = list(filter(lambda x: (x + 1) % 2, numList))  # （x+1）奇偶互换
print(outList)

</code></pre>
<ol start="3">
<li>编写程序，生成包含20个随机数的列表，然后将前10个元素升序排列，后10个元素降序排列，并输出结果。</li>
</ol>
<pre><code class="language-python">import random
numList = [random.randint(0, 9) for i in range(20)]
print(numList)
print(sorted(numList[:10]) + sorted(numList[10:], reverse=True))
</code></pre>
<ol start="4">
<li>编写程序，让用户在键盘上输入一个包含若干整数的列表，输出翻转后的列表。</li>
</ol>
<pre><code class="language-python">inputList = eval(input(&quot;请输入一个列表&quot;))
print(inputList[::-1])
</code></pre>
<p>元组练习：（选作）<br>
5.	写代码，有如下元祖，按照要求实现每一个功能<br>
print(&quot;----------------------------------------------&quot;)  tu = (&quot;alex&quot;, &quot;eric&quot;, &quot;Witharush&quot;)</p>
<pre><code class="language-python">
print(&quot;----------------------------------------------&quot;)
tu = (&quot;alex&quot;, &quot;eric&quot;, &quot;Witharush&quot;)
# a.计算元祖长度并输出
print(&quot;元组长度  %d&quot; % len(tu))
# b.获取元祖的第二个元素，并输出 print(tu[1])
print(tu[1])
# c.获取元祖的第 1-2 个元素，并输出
print(tu[0:2])
# d.请使用for输出元祖的元素
for i in tu:
    print(i)
# e.请使用for，len，range输出元素的索引
for j in range(len(tu)):
    print(j)
# f.请使用enumerate输出元祖元素和序号（序号从10开始）
for i, v in enumerate(tu, 10):
    print(i, v)
</code></pre>
<p>扩展练习：<br>
有以下列表<br>
nums = [2, 7, 11, 15, 1, 8]<br>
请找到列表中任意相加等于9的元素集合，如：[(2, 7), (1, 8)]</p>
<pre><code class="language-python">nums = [2, 7, 11, 15, 1, 8]
outNums = [(nums[i], nums[j]) for i in range(len(nums))
           for j in range(i + 1, len(nums))
           if nums[i] + nums[j] == 9]
print(outNums)

# 第二种解法
nums = [2, 7, 11, 15, 2, 1, 8]
nums_set = list(set(nums))  # 转集合的目的是为了去重
outNums = [(i, j) for index, i in enumerate(nums_set)
           for j in nums_set[index+1:]
           if i + j == 9]
print(outNums)  # [(1, 8), (2, 7)]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python第二次作业]]></title>
        <id>https://blog.youis.top/post/python-di-er-ci-zuo-ye/</id>
        <link href="https://blog.youis.top/post/python-di-er-ci-zuo-ye/">
        </link>
        <updated>2020-04-18T07:55:08.000Z</updated>
        <summary type="html"><![CDATA[<p>顺便吐槽一下，我们老师。<br>
每节课都有作业。。。。<br>
🙃🙃🙃🙃</p>
]]></summary>
        <content type="html"><![CDATA[<p>顺便吐槽一下，我们老师。<br>
每节课都有作业。。。。<br>
🙃🙃🙃🙃</p>
<!-- more -->
<pre><code class="language-python"># encoding: utf-8
&quot;&quot;&quot;
@author: Eden
@contact: .....
@time: 2020/4/14 14:38
@file: problem.py
@desc: 
&quot;&quot;&quot;

# 创建一个空列表，命名为names，往里面添加 Lihua、Rain、Jack、Xiuxiu、Peiqi和Black元素。
names = list()
names.append(&quot;Lihua&quot;)
names.append(&quot;Rain&quot;)
names.append(&quot;Jack&quot;)
names.append(&quot;Xiuxiu&quot;)
names.append(&quot;Peiqi&quot;)
names.append(&quot;Black&quot;)
# Names=[]
# Names.append(“”)
# 往1中的names列表里Black前面插入一个Blue。
names.insert(-1, &quot;Blue&quot;)
# 把names列表中Xiuxiu的名字改成中文。
names[names.index(&quot;Xiuxiu&quot;)] = &quot;秀秀&quot;
# 往names列表中Rain后面插入一个子列表[&quot;oldboy&quot;,&quot;oldgirl&quot;]。
names.insert(names.index(&quot;Rain&quot;)+1, [&quot;oldboy&quot;, &quot;oldgirl&quot;])
print(names)  # 验证
# 返回names列表中Peiqi的索引值（下标）
print(names.index(&quot;Peiqi&quot;))
# 创建新列表[1,2,3,4,2,5,6,2,]，合并到names列表中。
numbers = [1, 2, 3, 4, 2, 5, 6, 2]
names.extend(numbers)  # extend()方法表示合并
print(names)
# 取出names列表中索引4-7的元素。
print(names[4:8])
# 取出names列表中索引2-10的元素，步长为2
print(names[2:11:2])
# 取出names列表中最后3个元素。
print(names[-3:])  # [-3:]表示取值范围为从列表的倒数第三个到末尾
# 循环names列表，打印每个元素的索引值和元素。
for index, i in enumerate(names):
    print(index, i)
    # 循环names列表，打印每个元素的索引值和元素，当索引值为偶数时，把对应的元素改成-1。
for index, i in enumerate(names):
    if index % 2 == 0:
        names[index] = -1
        # print(index, i)
print(names)
# names列表里有3个2，请返回第二个2的索引值，动态找

print(names.index(2, names.index(2) + 1),)
</code></pre>
<p>好了，不多说了。我要去写第三次作业了。😘😘😘</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python十一道练习]]></title>
        <id>https://blog.youis.top/post/python-shi-yi-dao-lian-xi/</id>
        <link href="https://blog.youis.top/post/python-shi-yi-dao-lian-xi/">
        </link>
        <updated>2020-04-13T07:32:23.000Z</updated>
        <summary type="html"><![CDATA[<p>python课后作业<br>
🤡🤡🤡🤡</p>
]]></summary>
        <content type="html"><![CDATA[<p>python课后作业<br>
🤡🤡🤡🤡</p>
<!-- more -->
<p>1.编写程序，输入一个自然数字符串，然后输出各位数字之和。例如，输入字符串1234，输出10.</p>
<pre><code class="language-python">from functools import reduce

input_str = input(&quot;请输入一个字符串&quot;)

print(reduce(lambda x, y: int(x) + int(y), input_str))
</code></pre>
<p>2.编写程序，输入一个字符串，输出翻转（首尾交替）后的字符串。例如，输入字符串12345，输出54321.</p>
<pre><code class="language-python">input_str = input(&quot;请输入一个字符串&quot;)
input_str = input_str[::-1]
print(input_str)
</code></pre>
<p>3.编写程序，输入一个包含若干整数的列表，输出列表中的最大值。例如，输入[1，2，3，4，5，888]，输出888.</p>
<pre><code class="language-python">input_list = eval(input(&quot;请输入一个列表&quot;))
print(max(input_list))
</code></pre>
<p>4.编写程序，输入一个包含若干整数的列表，把列表中所有整数转换为字符串，然后输出包含这些字符串的列表。例如，输入[1，2，3，4，5，888]，输出['1'，'2'，'3'，'4'，'5'，'888']。</p>
<pre><code class="language-python">input_list = eval(input(&quot;请输入一个列表&quot;))

print(list(map(str, input_list)))

</code></pre>
<p>5.编写程序，输入一个包含若干任意数据的列表，输出该列表中等价于True的元素组成的列表。例如，输入[1，2，0，None，False，'a']，输出[1，2，'a']。</p>
<pre><code class="language-python">def fun(new_str):
    if new_str is None:
        return False
    if new_str is False:
        return False
    if new_str == 0:
        return False
    return True


input_list = eval(input(&quot;请输入一个列表&quot;))
OutList = list(filter(fun, input_list))
print(OutList)
</code></pre>
<p>6.编写程序，输入一个包含若干自然数的列表，输出这些自然数的平均值。</p>
<pre><code class="language-python">from functools import reduce

input_list = eval(input(&quot;请输入一个列表&quot;))
out_int = reduce((lambda x, y: x + y), input_list)
print(&quot;%.3f&quot; % (out_int / len(input_list)))
</code></pre>
<p>7.编写程序，输入一个包含若干自然数的列表，输出这些自然数降序排列的新列表。</p>
<pre><code class="language-python">input_list = eval(input(&quot;请输入一个列表&quot;))

new_list = sorted(input_list, reverse=True)
print(new_list)
</code></pre>
<p>8.编写程序，输入一个包含若干自然数的列表，输出一个新列表，新列表中每个元素为原列表中每个自然数的位数。例如，输入[1，888，99，23456]，输出为[1，3，2，5]。</p>
<pre><code class="language-python">input_list = eval(input(&quot;请输入一个列表&quot;))
out_list = list(map(lambda x: len(str(x)), input_list))
print(out_list)
</code></pre>
<p>9.编写程序，输入一个包含若干实数的列表，输出其中绝对值最大的实数。例如，输入[-8，64，3.5，-89]，输出-89。</p>
<pre><code class="language-python">from functools import reduce


def fun(x, y):
    if abs(x) &gt; abs(y):
        return x
    else:
        return y


input_list = eval(input(&quot;请输入一个列表&quot;))
out_list = reduce(fun, input_list)
print(out_list)
</code></pre>
<p>10.编写程序，输入一个包含若干整数的列表，输出这些整数的乘积。例如，输入[-2，3，4]，输出-24。</p>
<pre><code class="language-python">from functools import reduce

input_list = eval(input(&quot;请输入一个列表&quot;))
output = reduce(lambda x, y: x * y, input_list)
print(output)
</code></pre>
<p>11.编写程序，输入两个包含着若干整数的等长列表，把这两个列表看作两个向量，输出这两个向量的内积。</p>
<pre><code class="language-python">from functools import reduce

li1 = eval(input('请输入第一个列表'))
li2 = eval(input('请输入第二个列表'))
print(list(reduce(lambda x, y: x * y, (li1, li2))))
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python笔记]]></title>
        <id>https://blog.youis.top/post/pythonbiji/</id>
        <link href="https://blog.youis.top/post/pythonbiji/">
        </link>
        <updated>2020-04-13T06:58:53.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="身份运算符">身份运算符</h1>
<p>身份运算符用于比较两个对象的<strong>内存地址</strong>是否一致——是否是对同一个对象的引用</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="身份运算符">身份运算符</h1>
<p>身份运算符用于比较两个对象的<strong>内存地址</strong>是否一致——是否是对同一个对象的引用</p>
<!-- more -->
<h2 id="is-与-is-not">is 与 is  not</h2>
<table>
<thead>
<tr>
<th>运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:right">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>is</td>
<td style="text-align:center">is是判断两个标识符是不是引用同一个对象</td>
<td style="text-align:right">x is y，类似id(x)==id(y)</td>
</tr>
<tr>
<td>is not</td>
<td style="text-align:center">is not是判断两个标识符是不是引用不同对象</td>
<td style="text-align:right">x is not y，类似id(x)!=id(y)</td>
</tr>
</tbody>
</table>
<h2 id="is与区别">is与==区别：</h2>
<p>is用于判断两个变量引用对象是否为同一个<br>
==用于判断引用变量的值是否相等<br>
判断None与False用is</p>
<pre><code class="language-python">    if new_str is None:
        return False
    if new_str is False:
        return False
</code></pre>
<h1 id="输入列表">输入列表</h1>
<pre><code class="language-python">
'''
编写程序，输入一个包含若干整数的列表，输出列表中的最大值。例如，输入[1, 2, 3,4, 5, 888]输出888。
输入[1, 2, 3,4, 5, 888]
eval就会把它从字符串转换为列表。
'''
input_list = eval(input(&quot;请输入一个列表&quot;))

print(max(input_list))
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python安装教程]]></title>
        <id>https://blog.youis.top/post/python-an-zhuang-jiao-cheng/</id>
        <link href="https://blog.youis.top/post/python-an-zhuang-jiao-cheng/">
        </link>
        <updated>2020-03-25T05:38:51.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="1-下载python解释器并安装">1. 下载python解释器并安装</h1>
<p>官方地址: <a href="https://www.python.org/downloads/release/python-377/">点击下载</a><br>
🤡🤡🤡</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="1-下载python解释器并安装">1. 下载python解释器并安装</h1>
<p>官方地址: <a href="https://www.python.org/downloads/release/python-377/">点击下载</a><br>
🤡🤡🤡</p>
<!-- more -->
<p>查找对应版本，找到目标文件： <a href="https://www.python.org/ftp/python/3.7.7/python-3.7.7-amd64.exe">Windows x86-64 executable installer</a> 下载即可</p>
<figure data-type="image" tabindex="1"><img src="http://qiniu.youis.top/image-20200325121059112.png" alt="image-20200325121059112" loading="lazy"></figure>
<h1 id="2-安装解释器">2. 安装解释器</h1>
<p>(1)  点击.exe文件，注意：勾选添加到环境变量，然后点击（customize installation）自定义安装，<br>
<img src="http://qiniu.youis.top/image-20200325121124154.png" alt="image-20200325121124154" loading="lazy"></p>
<p>（2）进入如下界面，这是一些可选的项，全部默认勾选进行下一步<br>
<img src="http://qiniu.youis.top/image-20200325121131108.png" alt="image-20200325121131108" loading="lazy"></p>
<p>（3）选择安装路径，选择自己的安装路径</p>
<figure data-type="image" tabindex="2"><img src="http://qiniu.youis.top/image-20200325121145741.png" alt="image-20200325121145741" loading="lazy"></figure>
<p>（4）安装<br>
<img src="http://qiniu.youis.top/image-20200325121155998.png" alt="image-20200325121155998" loading="lazy"></p>
<figure data-type="image" tabindex="3"><img src="http://qiniu.youis.top/image-20200325121203778.png" alt="image-20200325121203778" loading="lazy"></figure>
<pre><code>     测试是否安装成功，在dos控制台窗口输入python,pip命令。
</code></pre>
<figure data-type="image" tabindex="4"><img src="http://qiniu.youis.top/image-20200325121246869.png" alt="image-20200325121246869" loading="lazy"></figure>
<h1 id="升级pip版本如果需要则使用">升级pip版本（如果需要则使用）</h1>
<figure data-type="image" tabindex="5"><img src="http://qiniu.youis.top/image-20200325121255095.png" alt="image-20200325121255095" loading="lazy"></figure>
<ol>
<li>单独下载pip并安装（如果python中已经存在，则不需要）</li>
</ol>
<figure data-type="image" tabindex="6"><img src="http://qiniu.youis.top/image-20200325121305672.png" alt="image-20200325121305672" loading="lazy"></figure>
<ol>
<li>下载链接</li>
</ol>
<p><a href="https://pypi.python.org/pypi/pip#downloads">https://pypi.python.org/pypi/pip#downloads</a></p>
<ol start="2">
<li>[解压]{.underline}</li>
</ol>
<figure data-type="image" tabindex="7"><img src="http://qiniu.youis.top/image-20200325121318107.png" alt="image-20200325121318107" loading="lazy"></figure>
<ol start="3">
<li>安装pip，默认安装在python的script目录下</li>
</ol>
<figure data-type="image" tabindex="8"><img src="http://qiniu.youis.top/image-20200325121333792.png" alt="image-20200325121333792" loading="lazy"></figure>
<ol start="4">
<li>配置pip环境变量，在window的环境变量path中</li>
</ol>
<figure data-type="image" tabindex="9"><img src="http://qiniu.youis.top/image-20200325121340959.png" alt="image-20200325121340959" loading="lazy"></figure>
<ol start="5">
<li>测试是否安装成功</li>
</ol>
<figure data-type="image" tabindex="10"><img src="http://qiniu.youis.top/image-20200325121348746.png" alt="image-20200325121348746" loading="lazy"></figure>
<h1 id="3-进行扩展库安装">3.  进行扩展库安装</h1>
<ol>
<li>查看已安装的模块</li>
</ol>
<figure data-type="image" tabindex="11"><img src="http://qiniu.youis.top/image-20200325121505990.png" alt="image-20200325121505990" loading="lazy"></figure>
<ol start="2">
<li>进行在线安装</li>
</ol>
<figure data-type="image" tabindex="12"><img src="http://qiniu.youis.top/image-20200325121513476.png" alt="image-20200325121513476" loading="lazy"></figure>
<p>也可以通过其他镜像下载：pip install -i http://pypi.douban.com/simple --trusted-host pypi.douban.com pandas</p>
<ol start="3">
<li>
<p>离线安装</p>
<ol>
<li>
<p>下载模块文件.whl</p>
<p>地址： <a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/">https://www.lfd.uci.edu/~gohlke/pythonlibs/</a></p>
<p>选择对应的whl文件下载：</p>
</li>
</ol>
</li>
</ol>
<figure data-type="image" tabindex="13"><img src="http://qiniu.youis.top/image-20200325121530859.png" alt="image-20200325121530859" loading="lazy"></figure>
<ol start="2">
<li>通过pip安装</li>
</ol>
<figure data-type="image" tabindex="14"><img src="http://qiniu.youis.top/image-20200325121538377.png" alt="image-20200325121538377" loading="lazy"></figure>
<ol start="4">
<li>卸载</li>
</ol>
<figure data-type="image" tabindex="15"><img src="http://qiniu.youis.top/image-20200325121545274.png" alt="image-20200325121545274" loading="lazy"></figure>
<ol start="4">
<li>
<p>下载并安装集成开发环境PyCharm或者Anaconda3</p>
<p>官方地址：<a href="https://www.jetbrains.com/pycharm/download/#section=windows">[https://www.jetbrains.com/pycharm/download/#section=windows]{.underline}</a></p>
</li>
</ol>
<figure data-type="image" tabindex="16"><img src="http://qiniu.youis.top/image-20200325121555613.png" alt="image-20200325121555613" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux高级运维笔记（第一章）]]></title>
        <id>https://blog.youis.top/post/BMg6sEDxV/</id>
        <link href="https://blog.youis.top/post/BMg6sEDxV/">
        </link>
        <updated>2020-03-15T07:28:26.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="linux系统简介">linux系统简介</h1>
<p>目前市场占有率最高的商业版Linux：RedHat<br>
被普遍使用的Liunx发行版本:Centos | Ubuntu| Debian |Fedora |Gento</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="linux系统简介">linux系统简介</h1>
<p>目前市场占有率最高的商业版Linux：RedHat<br>
被普遍使用的Liunx发行版本:Centos | Ubuntu| Debian |Fedora |Gento</p>
<!-- more -->
<h2 id="linux的目录结构">Linux的目录结构</h2>
<p>Linux系统中只有一个树状结构，根目录“/”位于所有目录和文件的顶端，是唯一的根结点。<br>
<img src="https://image.youis.top/20200424153602.png" alt="" loading="lazy"></p>
<ul>
<li>/：根目录，只包含目录，不包含具体文件；</li>
<li>/etc：主要包含系统管理文件和配置文件；</li>
<li>/bin：存放可执行的文件，如常用命令ls、mkdir、rm等的二进制文件都存放在该目录中；</li>
<li>/home：普通用户的工作目录，每个用户都有一个/home目录；</li>
<li>/usr：包含所有的用户程序（/usr/bin）、库文件（/usr/lib）、文档（/usr/share/doc）等，是占用空间最大的目录。</li>
<li>/dev：存放设备文件，包括块设备文件（如磁盘对应文件）、字符设备文件（如键盘对应文件）等；</li>
<li>/root：超级用户，即管理员的工作目录；</li>
<li>/lib：主要存放动态链接共享库文件，类似于Windows中的.dll文件，该目录中的文件一般以.a、.dll、.so结尾（后缀不代表文件类型），也会存放与内核模块相关的文件；</li>
<li>/boot：存放操作系统启动时需要用到的文件，如内核文件、引导程序文件等；</li>
<li>/mnt：存储挂载存储设备的挂载目录；</li>
<li>/proc：存放系统内存的映射，可直接通过访问该目录来获取系统信息；</li>
<li>/opt：存放附加的应用程序软件包；</li>
<li>/tmp：存放临时文件，重启系统后该目录的文件不会被保存。每个用户都能创建该目录，但不能删除其它用户的/tmp目录；</li>
<li>/swap：存放虚拟内存交换时所用文件。</li>
</ul>
<h2 id="linux系统的启动流程">Linux系统的启动流程</h2>
<p>从计算机的角度分析，接通电源后，需经过如下步骤，操作系统才会启动：</p>
<ol>
<li>BIOS加电自检；</li>
<li>MBR系统引导；</li>
<li>加载内核。</li>
</ol>
<h3 id="bios加电自检">BIOS加电自检</h3>
<p>BIOS与加电自检存在包含关系：BIOS全称Basic Input/Output System，即基本输入输出系统，是一个永久刻录在ROM中的软件；加电自检原意为Power On Self Test（POST），是BIOS的一个主要部分。<br>
计算机在接通电源后BIOS通过POST来加载硬件信息，进行内存、CPU、主板等的检测，若硬件设备正常运作，BIOS会寻找硬盘第一个扇区中存储的数据，使用MBR中的数据激活引导加载程序。</p>
<h3 id="mbr系统引导">MBR系统引导</h3>
<p>MBR全称Master Boot Recode，是一种磁盘分区格式，也是以此种格式的磁盘中0盘片0扇区中存储的一段记录——主引导记录。磁盘中扇区的大小为512字节，主引导记录MBR占据第一个扇区的前446字节，剩余的空间依次存储一个64字节的磁盘分区表，和一个用于标识MBR是否有效的2字节的魔数。<br>
主引导记录MBR中包含一个实现引导加载功能的程序——Boot Loader。由于BIOS只能访问很少量的数据，所以MBR中的引导加载程序其实只是一段初始程序的加载程序（Initial Program Loader，简称IPL），这段程序唯一的功能就是定位并加载Boot Loader的主体程序。<br>
因为以上原因，引导加载分为两个阶段：<br>
第一阶段，BIOS引导IPL（此时系统启动的控制权由BIOS转移到MBR），获取Boot Loader主体程序在磁盘中的位置；<br>
第二阶段，Boot Loader主体程序与操作系统对应的内核，定位到内核文件所在位置，并将其加载到计算机内存中（此时系统启动的控制权由MBR转到到内核）。</p>
<h3 id="加载内核">加载内核</h3>
<p>内核是操作系统的核心，Linux操作系统的内核即Linux。<br>
内核以一种自解压的压缩格式存储，它与一个初始化的内存映像和存储设备映像表一起存储在/boot目录中。<br>
在选定的内核被加载到内存中并开始执行之前需先从压缩格式中解压，一旦内核自解压完成，systemd进程（早期版本中为init进程）便被启动。<br>
systemd进程的启动标识着引导过程的结束，也标识启动过程的开始。在系统启动之初，由于系统中没有除systemd之外的程序执行，系统初始化工作尚未完成，因此计算机不能执行任何和用户相关的功能性工作。<br>
系统初始化需要做的事情非常多，如挂载文件系统、启动后台服务等等，这些初始化工作都由systemd进程完成。对用户而言，系统初始化完成后，系统才算正式启动。</p>
]]></content>
    </entry>
</feed>
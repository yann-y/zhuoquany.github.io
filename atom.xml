<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://youis.top</id>
    <title>Eden的博客</title>
    <updated>2020-10-19T03:07:15.392Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://youis.top"/>
    <link rel="self" href="https://youis.top/atom.xml"/>
    <subtitle>浮生若梦，人生几何</subtitle>
    <logo>https://youis.top/images/avatar.png</logo>
    <icon>https://youis.top/favicon.ico</icon>
    <rights>All rights reserved 2020, Eden的博客</rights>
    <entry>
        <title type="html"><![CDATA[python实现二维码]]></title>
        <id>https://youis.top/post/Kc4zbUSnd/</id>
        <link href="https://youis.top/post/Kc4zbUSnd/">
        </link>
        <updated>2020-10-16T06:20:39.000Z</updated>
        <summary type="html"><![CDATA[<p>实现二维码，<br>
四位二维码，前两位数字，后两位大写字母。<br>
😁😁😁效果如下：<br>
<img src="https://image.youis.top/test.jpg" alt="" loading="lazy"><br>
是不是很有哪味🤞🤞🤞</p>
]]></summary>
        <content type="html"><![CDATA[<p>实现二维码，<br>
四位二维码，前两位数字，后两位大写字母。<br>
😁😁😁效果如下：<br>
<img src="https://image.youis.top/test.jpg" alt="" loading="lazy"><br>
是不是很有哪味🤞🤞🤞</p>
<!-- more -->
<pre><code class="language-python"># encoding: utf-8
&quot;&quot;&quot;
@author: Eden
@contact: .....
@time: 2020/10/15 14:52
@file: test06.py
@desc: 
&quot;&quot;&quot;
from PIL import Image, ImageDraw, ImageFont
import random


# 生成验证码

# ASCII 字符的对应值
# 生成随机字母
def randomchar(x):
    if i &lt;= 1:  # 前两位是数字
        return chr(random.randint(48, 57))  # 随机生成数字
    else:  # 其他的是A~Z
        return chr(random.randint(65, 90))  # 随即生成A~Z
    # 数字0~9的字符对应48~57
    # 小写字母对应97~122


def randomcl1():
    return (random.randint(64, 255),
            random.randint(64, 255),
            random.randint(64, 255))


def randomcl2():
    return (random.randint(0, 127),
            random.randint(0, 127),
            random.randint(0, 127))


width = 240
height = 100

# 创建画板
img = Image.new(&quot;RGB&quot;, (width, height), (255, 255, 255))
# 创建画笔
draw = ImageDraw.Draw(img)
# 创建字体
font = ImageFont.truetype(&quot;arial.ttf&quot;, 60)

# 填充像素
for x in range(width):
    for y in range(height):
        draw.point((x, y), randomcl1())

# 生成验证码，填充颜色
for i in range(4):
    draw.text((60 * i, 15), randomchar(x), randomcl2(), font)
img.show()
img.save(&quot;test.jpg&quot;)

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pytorch测试demo]]></title>
        <id>https://youis.top/post/KXGXsI0Gv/</id>
        <link href="https://youis.top/post/KXGXsI0Gv/">
        </link>
        <updated>2020-10-16T02:09:50.000Z</updated>
        <summary type="html"><![CDATA[<p>pytorch一个简单的测试代码。<br>
手写数字识别<br>
😁😁😁😁</p>
]]></summary>
        <content type="html"><![CDATA[<p>pytorch一个简单的测试代码。<br>
手写数字识别<br>
😁😁😁😁</p>
<!-- more -->
<pre><code class="language-python"># coding: utf-8
import torch
import torch.nn as nn
import torchvision.datasets as dsets
import torchvision.transforms as transforms
from torch.autograd import Variable
import torch.utils.data as Data
import matplotlib.pyplot as plt

input_size = 784  # 输入大小
hidden_size = 500  # 第一层的神经元个数
num_classes = 10  # 类别个数
num_epochs = 5  # 迭代次数
batch_size = 100  # 每一批的数目
learning_rate = 0.001  # 学习率

train_dataset = dsets.MNIST(root='./data', train=True,
                            transform=transforms.ToTensor(), download=True)  # 加载数据集
test_dataset = dsets.MNIST(root='./data', train=False,
                           transform=transforms.ToTensor(), download=True)  # 加载测试集

train_loader = torch.utils.data.DataLoader(dataset=train_dataset,
                                           batch_size=batch_size, shuffle=True)  # shuffle为True：在每个epoch重新排列数据
test_loader = torch.utils.data.DataLoader(dataset=test_dataset,
                                          batch_size=batch_size, shuffle=False)


# In[4]:


class Net(nn.Module):
    def __init__(self, input_size, hidden_size, num_classes):
        super(Net, self).__init__()
        self.fc1 = nn.Linear(input_size, hidden_size)
        self.relu = nn.ReLU()
        self.fc2 = nn.Linear(hidden_size, num_classes)

    def forward(self, x):
        out = self.fc1(x)
        out = self.relu(out)
        out = self.fc2(out)

        return out


# In[5]:


net = Net(input_size, hidden_size, num_classes)  # 创建模型
criterion = nn.CrossEntropyLoss()  # 创建损失函数（用的交叉熵）
optimizer = torch.optim.Adam(net.parameters(), lr=learning_rate)  # 梯度下降

# In[6]:


for epoch in range(num_epochs):
    for i, (images, labels) in enumerate(train_loader):
        images = Variable(images.view(-1, 28 * 28))
        label = Variable(labels)

        optimizer.zero_grad()  # 将权重初始化为0
        outputs = net(images)
        loss = criterion(outputs, labels)
        loss.backward()

        optimizer.step()  # 更新权重

        if (i + 1) % 100 == 0:
            print('Epoch [%d/%d], Step [%d/%d],Loss:%.4f' % (epoch + 1, num_epochs, i + 1,
                                                             len(train_dataset) // batch_size, loss.item()))

# In[7]:


# 预测数据
correct = 0
total = 0
for images, labels in test_loader:
    images = Variable(images.view(-1, 28 * 28))
    outputs = net(images)
    _, predicted = torch.max(outputs.data, 1)
    total += labels.size(0)
    correct += (predicted == labels).sum()
print('Accuracy of the network on the 10000 test images:%d %%' % (100 * correct // total))

# In[8]:


plt.imshow(test_dataset.data[-25].numpy(), cmap='gray')
plt.title('%i ' % (predicted[-25]))

plt.show()

# In[9]:


# 储存模型
torch.save(net, 'model1.pkl')

# In[10]:


# 加载模型
model = torch.load('model1.pkl')

# In[11]:


# 预测数据
correct = 0
total = 0
for images, labels in test_loader:
    images = Variable(images.view(-1, 28 * 28))
    outputs = model(images)
    _, predicted = torch.max(outputs.data, 1)
    total += labels.size(0)
    correct += (predicted == labels).sum()
print('Accuracy of the network on the 10000 test images:%d %%' % (100 * torch.true_divide(correct, total)))

# In[12]:


torch.save(net.state_dict(), 'model2.pkl')
net.load_state_dict(torch.load('model2.pkl'))

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python期末考试案例代码]]></title>
        <id>https://youis.top/post/DHq7otHwc/</id>
        <link href="https://youis.top/post/DHq7otHwc/">
        </link>
        <updated>2020-08-31T11:30:00.000Z</updated>
        <summary type="html"><![CDATA[<p>期末考试的案例代码总结<br>
😁😁😁😁</p>
]]></summary>
        <content type="html"><![CDATA[<p>期末考试的案例代码总结<br>
😁😁😁😁</p>
<!-- more -->
<pre><code class="language-Python">from random import randint
'''
编写程序，生成包含1000个0到100之间的随机整数，并统计每个元素出现的次数
'''
lis = [randint(0, 100) for i in range(0, 1000)]
for i in set(lis):
    print(i, &quot;:&quot;, lis.count(i))
</code></pre>
<pre><code class="language-python">    '''
编写程序，生成包含20个随机数的列表，然后将前10个元素升序排列，
后10个元素降序排列，并输出结果。
'''
from random import randint
lis = [randint(0, 100) for i in range(0, 20)]
print(sorted(lis[:10])+sorted(lis[10:],reverse=True))
</code></pre>
<pre><code class="language-python">'''
编写程序，生成一个包含 20 个随机整数的列表，
然后对其中偶数下标的元素进行降序排列，奇数下标的元素不变。
'''
from random import randint
lis = [randint(0, 100) for i in range(0, 20)]
even = sorted(lis[::2], reverse=True)  # 偶数下标
print(lis)
print(even)
for i in range(0, 10):
    lis[i*2] = even[i]
print(lis)
</code></pre>
<pre><code class="language-python">'''
判断字符串是否为回文，使用切片实现。
'''
oldstr = &quot;123aba321&quot;
if oldstr == oldstr[::-1]:
    print(&quot;是回文字符串&quot;)
else:
    print(&quot;不是回文字符串&quot;)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ansible部署K8s_v1.18.4环境]]></title>
        <id>https://youis.top/post/154qMkJXW/</id>
        <link href="https://youis.top/post/154qMkJXW/">
        </link>
        <updated>2020-06-28T13:18:15.000Z</updated>
        <summary type="html"><![CDATA[<p>Kubernetes是Goole开源的一个容器编排引擎，它支持自动化部署、大规模可伸缩、应用容器化管理。<br>
本文介绍如何在本地自行搭建一套k8s集群。<br>
本文所涉及的所有配置文件详见&quot;离线包和镜像汇总资料&quot;。<br>
<img src="https://image.youis.top/QQ%E6%88%AA%E5%9B%BE20200627233552.jpg" alt="" loading="lazy"></p>
]]></summary>
        <content type="html"><![CDATA[<p>Kubernetes是Goole开源的一个容器编排引擎，它支持自动化部署、大规模可伸缩、应用容器化管理。<br>
本文介绍如何在本地自行搭建一套k8s集群。<br>
本文所涉及的所有配置文件详见&quot;离线包和镜像汇总资料&quot;。<br>
<img src="https://image.youis.top/QQ%E6%88%AA%E5%9B%BE20200627233552.jpg" alt="" loading="lazy"></p>
<!-- more -->
<p>由于Markdown不好编排，我附上Word连接<br>
👇👇👇👇<br>
<a href="http://cloud.youis.top/?r=/download&amp;path=L0Fuc2libGUvQW5zaWJsZemDqOe9sks4c192MS4xOC40546v5aKDMjAyMDA2MjTvvIjoh6rliqjljJbohJrmnKzvvIkuZG9jeA%3D%3D">Ansible部署K8s_v1.18.4环境.docx</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python检索关键字]]></title>
        <id>https://youis.top/post/nqFG2uASl/</id>
        <link href="https://youis.top/post/nqFG2uASl/">
        </link>
        <updated>2020-06-20T02:04:51.000Z</updated>
        <summary type="html"><![CDATA[<p>找到在某个目录下面所有的文件内容里面有关键字&quot;info&quot;的文件，将这些文件路径存储在一个t1.pkl的文件里面</p>
]]></summary>
        <content type="html"><![CDATA[<p>找到在某个目录下面所有的文件内容里面有关键字&quot;info&quot;的文件，将这些文件路径存储在一个t1.pkl的文件里面</p>
<!-- more -->
<pre><code class="language-python"># encoding: utf-8
&quot;&quot;&quot;
@author: Eden
@contact: .....
@time: 2020/6/20 9:21
@file: test.py
@desc:
&quot;&quot;&quot;
import os
import re


def listdir(path):
    &quot;&quot;&quot;
    遍历出，目录下所有文件
    @param path:  str
    &quot;&quot;&quot;
    for file in os.listdir(path):
        file_path = os.path.join(path, file)
        if os.path.isdir(file_path):  # 如果该文件是目录
            # print(file_path)
            listdir(file_path)  # 继续递归遍历
        else:
            # print(file_path)
            keyword_search(file_path)  # 读取文件，搜索关键字。


def keyword_search(file_path):
    &quot;&quot;&quot;
    打开文件，搜索关键字。
    @param file_path:
    &quot;&quot;&quot;
    f1 = open(file_path, &quot;r&quot;, encoding=&quot;utf-8&quot;)
    content = f1.read()
    # print(&quot;输出文件内容：\n&quot;, content)  # 输出文件内容
    count = len(re.findall(keyword, content))
    # re.findall()返回的是一个列表
    if count != 0:  # 如果个数不为 0
        print(file_path)
        with open('t1.pkl', 'a+') as f:
            f.write(file_path + '\n')  # 保存到该文件


if __name__ == '__main__':
    # start = time.clock()
    work_path = r&quot;D:\python\TestProject\PythonClassroom\work20\test&quot;  # 待检索的目录
    keyword = &quot;info&quot;  # 检索的关键字
    if os.path.isdir(work_path):
        listdir(work_path)  # 目录遍历
    else:
        print(&quot;请输入一个目录！！&quot;)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决pycurl安装错误]]></title>
        <id>https://youis.top/post/HYW8Js4p1/</id>
        <link href="https://youis.top/post/HYW8Js4p1/">
        </link>
        <updated>2020-06-03T06:43:49.000Z</updated>
        <summary type="html"><![CDATA[<p>由于libcurl的源码编译因素，在安装pycurl可能会导致以下两种错误。</p>
]]></summary>
        <content type="html"><![CDATA[<p>由于libcurl的源码编译因素，在安装pycurl可能会导致以下两种错误。</p>
<!-- more -->
<p>错误1：</p>
<p>ImportError: pycurl: libcurl link-time ssl backend (<strong>openssl</strong>) is different from compile-time ssl backend (none/other)</p>
<p>解决办法：</p>
<p>错误1的解决办法如下：</p>
<pre><code class="language-shell"> pip uninstall pycurl
#export PYCURL_SSL_LIBRARY=[nss|openssl|ssl|gnutls]
#参数由报错信息括号里面的内容决定。这里括号里面是  openssl
export PYCURL_SSL_LIBRARY=openssl

pip install pycurl
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python实现查找和排序]]></title>
        <id>https://youis.top/post/dfjsdhfbjdsbfj/</id>
        <link href="https://youis.top/post/dfjsdhfbjdsbfj/">
        </link>
        <updated>2020-05-24T02:04:44.000Z</updated>
        <summary type="html"><![CDATA[<p>学习python的同时顺便复习数据结构。<br>
🙌没人<br>
👐比我<br>
👌更懂<br>
👆复习😜<br>
未完待续。。。</p>
]]></summary>
        <content type="html"><![CDATA[<p>学习python的同时顺便复习数据结构。<br>
🙌没人<br>
👐比我<br>
👌更懂<br>
👆复习😜<br>
未完待续。。。</p>
<!-- more -->
<h1 id="顺序查找">顺序查找</h1>
<h1 id="折半查找">折半查找</h1>
<p>def binary_search(nums, key):<br>
left, right = 0, len(nums) - 1<br>
while left &lt;= right:<br>
mid = (left + right) // 2<br>
if nums[mid] == key:<br>
# 返回索引位置<br>
return mid<br>
elif nums[mid] &lt; key:<br>
left = mid + 1<br>
elif nums[mid] &gt; key:<br>
right = mid - 1<br>
return -1  # 没有找到返回 -1</p>
<p>if <strong>name</strong> == '<strong>main</strong>':<br>
lis = [2, 3, 4, 5, 5, 5, 6, 7, 23, 45, 90]<br>
print(binary_search(lis, 110))</p>
<h1 id="分块查找">分块查找</h1>
<h1 id="直接插入排序">直接插入排序</h1>
<h1 id="折半插入排序">折半插入排序</h1>
<h1 id="希尔排序">希尔排序</h1>
<h1 id="冒泡排序">冒泡排序</h1>
<p>相信冒泡排序已经被大家所熟知,下面的代码对冒泡排序进行了简单优化。</p>
<pre><code class="language-python">def bubble_sort(nums):
    for i in range(len(nums) - 1):
        ex_flag = False
        for j in range(len(nums) - 1 - i):
            if nums[j] &gt; nums[j + 1]:
                nums[j], nums[j + 1] = nums[j + 1], nums[j]
                ex_flag = True
        if not ex_flag:
            return nums
    return nums


if __name__ == '__main__':
    lis = [2, 4, 5, 6, 7, 3, 5, 90, 45, 23, 5]
    print(bubble_sort(lis))
</code></pre>
<h1 id="快速排序">快速排序</h1>
<h1 id="简单选择排序">简单选择排序</h1>
<p>def select_sort(nums):<br>
for i in range(len(nums)):<br>
nums_min = i<br>
for j in range(i + 1, len(nums)):<br>
if nums[j] &lt; nums[nums_min]:<br>
nums_min = j<br>
nums[i], nums[nums_min] = nums[nums_min], nums[i]<br>
return nums</p>
<p>if <strong>name</strong> == '<strong>main</strong>':<br>
lis = [2, 4, 5, 6, 7, 3, 5, 90, 45, 23, 5]<br>
print(select_sort(lis))</p>
<h1 id="堆排序">堆排序</h1>
<h1 id="归并排序">归并排序</h1>
<h1 id="基数排序">基数排序</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[系统巡检脚本]]></title>
        <id>https://youis.top/post/xi-tong-xun-jian-jiao-ben/</id>
        <link href="https://youis.top/post/xi-tong-xun-jian-jiao-ben/">
        </link>
        <updated>2020-05-20T14:00:29.000Z</updated>
        <summary type="html"><![CDATA[<p>在生产环境中，作为日常巡检任务，时刻要注意主机的各种硬件状态，如果是规模较大的服务集群，一般使用zabbix等健康工具，如果只是一些小规模的服务主机，shell就会表现的更灵活，也更适用，下面是一个常用的系统巡检脚本。试运行，找出其中的错误，并修改，然后打印出执行结果。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在生产环境中，作为日常巡检任务，时刻要注意主机的各种硬件状态，如果是规模较大的服务集群，一般使用zabbix等健康工具，如果只是一些小规模的服务主机，shell就会表现的更灵活，也更适用，下面是一个常用的系统巡检脚本。试运行，找出其中的错误，并修改，然后打印出执行结果。</p>
<!-- more -->
<p>vi syscheck.sh</p>
<pre><code class="language-sh">#!/bin/bash

function system(){
echo &quot;#########################系统信息#########################&quot;
OS_TYPE=`uname`
OS_VER=`cat /etc/redhat-release`
OS_KER=`uname -a|awk '{print $3}'`
OS_TIME=`date +%F_%T`
OS_RUN_TIME=`uptime |awk '{print $3}'|awk -F '{print $1}'`
OS_LAST_REBOOT_TIME=`who -b|awk '{print $2,$3}'`
OS_HOSTNAME=`hostname`

echo &quot;    系统类型：$OS_TYPE&quot;
echo &quot;    系统版本：$OS_VER&quot;
echo &quot;    系统内核：$OS_KER&quot;
echo &quot;    当前时间：$OS_TIME&quot;
echo &quot;    运行时间：$OS_RUN_TIME&quot;
echo &quot;最后重启时间：$OS_LAST_REBOOT_TIME&quot;
echo &quot;    本机名称：$OS_HOSTNAME&quot;

function network(){

echo &quot;#########################网络信息#########################&quot;
INTERNET=(`ifconfig|grep ens|awk -F: '{print $1}'`)
for((i=0;i&lt;`echo ${#INTERNET[*]}`;i++))
do 
  OS_IP=`ifconfig ${INTERNET[$i]}|head -2|grep inet|awk '{print $2}'`
  echo &quot;      本机IP：${INTERNET[$i]}: $OS_IP&quot;
done
curl -I http://www.baidu.com &amp;&gt;/dev/null
if [ $? -eq 0 ]
then echo &quot;    访问外网：成功&quot;
else echo &quot;    访问外网：失败&quot;

}

function hardware(){

echo &quot;#########################硬件信息#########################&quot;
CPUID=`grep &quot;physical id&quot; /proc/cpuinfo |sort|uniq|wc -l`
CPUCORES=`grep &quot;cores&quot; /proc/cpuinfo|sort|uniq|awk -F: '{print $2}'`
CPUMODE=`grep &quot;model name&quot; /proc/cpuinfo|sort|uniq|awk -F '{print $2}'`

echo &quot;     CPU数量: $CPUID&quot;
echo &quot;     CPU核心:$CPUCORES&quot;
echo &quot;     CPU型号:$CPUMODE&quot;

MEMTOTAL=`free -m|grep Mem|awk '{print $2}'`
MEMFREE=`free -m|grep Mem|awk '{print $7}'`

echo &quot;  内存总容量: ${MEMTOTAL}MB&quot;
echo &quot;剩余内存容量: ${MEMFREE}MB&quot;

disksize=0
swapsize=`free|grep Swap|awk {'print $2'}`
partitionsize=(`df -T|sed 1d|egrep -v &quot;tmpfs|sr0&quot;|awk {'print $3'}`)
for ((i=0;i&lt;`echo ${#partitionsize[*]}`;i++))
do
disksize=`expr $disksize + ${partitionsize[$i]}`
done
((disktotal=\($disksize+$swapsize\)/1024/1024))

echo &quot;  磁盘总容量: ${disktotal}GB&quot;

diskfree=0
swapfree=`free|grep Swap|awk '{print $4}'`
partitionfree=(`df -T|sed 1d|egrep -v &quot;tmpfs|sr0&quot;|awk '{print $5}'`)
for ((i=0;i&lt;`echo ${#partitionfree[*]}`;i++))
do
diskfree=`expr $diskfree + ${partitionfree[$i]}`
done

((freetotal=\($diskfree+$swapfree\)/1024/1024))

echo &quot;剩余磁盘容量：${freetotal}GB&quot;
}


function secure(){
echo &quot;#########################安全信息#########################&quot;

countuser=(`last|grep &quot;still logged in&quot;|awk '{print $1}'|sort|uniq`)
for ((i=0;i&lt;`echo ${#countuser[*]}`;i++))
do echo &quot;当前登录用户：${countuser[$i]}&quot;
done

md5sum /etc/passwd &gt; /opt/passwd.db
md5sum -c --quiet /opt/passwd.db &amp;&gt;/dev/null
if [ $? -eq 0 ]
then echo &quot;    用户异常：否&quot;
else echo &quot;    用户异常：是&quot;
fi
}

function chksys(){
system
network
hardware
secure
}
</code></pre>
<p>提示一：<br>
<img src="https://image.youis.top/20200520220351.png" alt="" loading="lazy"><br>
if函数没有结尾  34行添加  fi<br>
提示二：</p>
<p><img src="https://image.youis.top/20200520220403.png" alt="" loading="lazy"><br>
函数 system 缺少  }  20行添加  }<br>
提示三：<br>
<img src="https://image.youis.top/20200520220416.png" alt="" loading="lazy"><br>
函数没有调用 在函数末尾调用 chksys函数<br>
提示四：<br>
<img src="https://image.youis.top/20200520220429.png" alt="" loading="lazy"></p>
<p>第9行 OS_RUN_TIME=<code>uptime |awk '{print $3}'|awk -F '{print $1}'</code>  AWK 存在管道信息,-F后面没有参数<br>
提示五：<br>
<img src="https://image.youis.top/20200520220439.png" alt="" loading="lazy"><br>
第43行 #CPUMODE=<code>grep &quot;model name&quot; /proc/cpuinfo|sort|uniq|awk -F '{print $2}'</code><br>
awk   -F  没有更参数</p>
<figure data-type="image" tabindex="1"><img src="https://image.youis.top/20200520215758.png" alt="" loading="lazy"></figure>
<p>修正代码：</p>
<pre><code class="language-sh">#!/bin/bash

function system(){
echo &quot;#########################系统信息#########################&quot;
OS_TYPE=`uname`
OS_VER=`cat /etc/redhat-release`
OS_KER=`uname -a|awk '{print $3}'`
OS_TIME=`date +%F_%T`
#OS_RUN_TIME=`uptime |awk '{print $3}'|awk -F '{print $1}'`
OS_RUN_TIME=`uptime |awk '{print $3}'|awk -F,  '{print $1}'`
OS_LAST_REBOOT_TIME=`who -b|awk '{print $2,$3}'`
OS_HOSTNAME=`hostname`

echo &quot;    系统类型：$OS_TYPE&quot;
echo &quot;    系统版本：$OS_VER&quot;
echo &quot;    系统内核：$OS_KER&quot;
echo &quot;    当前时间：$OS_TIME&quot;
echo &quot;    运行时间：$OS_RUN_TIME&quot;
echo &quot;最后重启时间：$OS_LAST_REBOOT_TIME&quot;
echo &quot;    本机名称：$OS_HOSTNAME&quot;
}
function network(){

echo &quot;#########################网络信息#########################&quot;
INTERNET=(`ifconfig|grep ens|awk -F: '{print $1}'`)
for((i=0;i&lt;`echo ${#INTERNET[*]}`;i++))
do 
  OS_IP=`ifconfig ${INTERNET[$i]}|head -2|grep inet|awk '{print $2}'`
  echo &quot;      本机IP：${INTERNET[$i]}: $OS_IP&quot;
done
curl -I http://www.baidu.com &amp;&gt;/dev/null
if [ $? -eq 0 ]
then echo &quot;    访问外网：成功&quot;
else echo &quot;    访问外网：失败&quot;
fi
}

function hardware(){

echo &quot;#########################硬件信息#########################&quot;
CPUID=`grep &quot;physical id&quot; /proc/cpuinfo |sort|uniq|wc -l`
CPUCORES=`grep &quot;cores&quot; /proc/cpuinfo|sort|uniq|awk -F: '{print $2}'`
#CPUMODE=`grep &quot;model name&quot; /proc/cpuinfo|sort|uniq|awk -F '{print $2}'`
CPUMODE=`grep &quot;model name&quot; /proc/cpuinfo|sort|uniq|awk -F: '{print $2}'`

echo &quot;     CPU数量: $CPUID&quot;
echo &quot;     CPU核心:$CPUCORES&quot;
echo &quot;     CPU型号:$CPUMODE&quot;

MEMTOTAL=`free -m|grep Mem|awk '{print $2}'`
MEMFREE=`free -m|grep Mem|awk '{print $7}'`

echo &quot;  内存总容量: ${MEMTOTAL}MB&quot;
echo &quot;剩余内存容量: ${MEMFREE}MB&quot;

disksize=0
swapsize=`free|grep Swap|awk {'print $2'}`
partitionsize=(`df -T|sed 1d|egrep -v &quot;tmpfs|sr0&quot;|awk {'print $3'}`)
for ((i=0;i&lt;`echo ${#partitionsize[*]}`;i++))
do
disksize=`expr $disksize + ${partitionsize[$i]}`
done
((disktotal=\($disksize+$swapsize\)/1024/1024))

echo &quot;  磁盘总容量: ${disktotal}GB&quot;

diskfree=0
swapfree=`free|grep Swap|awk '{print $4}'`
partitionfree=(`df -T|sed 1d|egrep -v &quot;tmpfs|sr0&quot;|awk '{print $5}'`)
for ((i=0;i&lt;`echo ${#partitionfree[*]}`;i++))
do
diskfree=`expr $diskfree + ${partitionfree[$i]}`
done

((freetotal=\($diskfree+$swapfree\)/1024/1024))

echo &quot;剩余磁盘容量：${freetotal}GB&quot;
}


function secure(){
echo &quot;#########################安全信息#########################&quot;

countuser=(`last|grep &quot;still logged in&quot;|awk '{print $1}'|sort|uniq`)
for ((i=0;i&lt;`echo ${#countuser[*]}`;i++))
do echo &quot;当前登录用户：${countuser[$i]}&quot;
done

md5sum /etc/passwd &gt; /opt/passwd.db
md5sum -c --quiet /opt/passwd.db &amp;&gt;/dev/null
if [ $? -eq 0 ]
then echo &quot;    用户异常：否&quot;
else echo &quot;    用户异常：是&quot;
fi
}

function chksys(){
system
network
hardware
secure
}
chksys
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python课堂案列]]></title>
        <id>https://youis.top/post/python-ke-tang-an-lie/</id>
        <link href="https://youis.top/post/python-ke-tang-an-lie/">
        </link>
        <updated>2020-05-15T06:24:48.000Z</updated>
        <summary type="html"><![CDATA[<p>重点讲解 杨辉三角 和 约瑟夫环报数游戏。<br>
💪💪💪💪<br>
python 永远滴神！！</p>
]]></summary>
        <content type="html"><![CDATA[<p>重点讲解 杨辉三角 和 约瑟夫环报数游戏。<br>
💪💪💪💪<br>
python 永远滴神！！</p>
<!-- more -->
<h1 id="例5-3-编写并使用能够生成斐波那契数列的生成器函数">例5-3 编写并使用能够生成斐波那契数列的生成器函数</h1>
<pre><code class="language-python">def demo(s):
    result = [0, 0]     #不能直接定义为元组，因为元组是不能对其中元素进行修改操作的。
    for ch in s:
        if ch.islower():
            result[1] += 1
        elif ch.isupper():
            result[0] += 1
    return tuple(result)
</code></pre>
<h1 id="例5-4-编写函数接收字符串参数返回一个元组其中第一个元素为大写字母个数第二个元素为小写字母个数">例5-4 编写函数，接收字符串参数，返回一个元组，其中第一个元素为大写字母个数，第二个元素为小写字母个数。</h1>
<pre><code class="language-python">def fun(s: str):
    result = [0, 0]
    for ch in s:
        if ch.islower():
            result[1] += 1
        elif ch.isupper():
            result[0] += 1
    return tuple(result)


if __name__ == '__main__':
    newstr = &quot;asdhasjgdAasghd&quot;
    print(len(newstr))
    print(fun(newstr))
</code></pre>
<h1 id="例5-5-编写函数接收一个整数t为参数打印杨辉三角前t行">例5-5  编写函数，接收一个整数t为参数，打印杨辉三角前t行。</h1>
<p>注意：看此教程前请先学习生成器的原理，yield返回的用法规律，不然可能会懵逼。<br>
下面我按照自己的理解写下思路：<br>
首先附上我们需要求得的杨辉三角：</p>
<pre><code>[1]
 
[1, 1]
 
[1, 2, 1]
 
[1, 3, 3, 1]
 
[1, 4, 6, 4, 1]
 
[1, 5, 10, 10, 5, 1]
 
[1, 6, 15, 20, 15, 6, 1]
 
[1, 7, 21, 35, 35, 21, 7, 1]
 
[1, 8, 28, 56, 70, 56, 28, 8, 1]
 
[1, 9, 36, 84, 126, 126, 84, 36, 9, 1]
</code></pre>
<p>很显然，是按照一行一个数列（list）实现的，也就是说，我们得在程序中不断的返回每一行的list并且打印出来<br>
第一步：先找规律，抽象化问题：<br>
首先我们观察到，第一行为[1]，我们直接初始化列表 ： p = [1]<br>
其次我们观察到，下面的每一行的开头结尾都是[1],那么我们可以推导出每一行的规律为：[1]+.........+[1]<br>
那么我们发现，从第三行开始中间的 [2]，第四行中间的 [3，3]，第五行中间的 [4,6,4] 等等以此类推才是我们需要推导的部分</p>
<p>第一行：[1] 设 p = [1]</p>
<p>第二行：[1]+[1] 设 p = [1,1]</p>
<p>第三行：[1]+[2]+[1] 设 p = [1,2,1]</p>
<p>第四行：[1]+[3]+[3]+[1]设 p = [1,3,3,1]</p>
<p>....</p>
<p>经过找规律，我们发现，每一个新的list中间的部分，都等于上一行list的：第0个元素+第1个元素，第1个元素+第2个元素，第2个元素+第3个元素,.......</p>
<p>加上头尾也就是[1] +[ p[0]+p[1] ]+[ p[1]+p[2] ].....+[1]</p>
<p>比如上面第三行：p[0] = 1, p[1] = 2, p[2] = [1]</p>
<p>那么第四行就是：[1]   [1+2]   [2+1]   [1]</p>
<p>后面以此类推<br>
既然核心点是这个除去首位两个 [1] 的中间部分：[p[0] + p[1]]+[p[1] + p[2]]+[p[2] + p[3]]........</p>
<p>我们很容易得到规律：[p[i] + p[i+1]]# for i  in range(x)</p>
<p>如果还没看懂，你可以找一张纸，将每一行都按照这个规律写出来：</p>
<p>new p代表本行list的中间部分，p代表上一行list：</p>
<pre><code>[1]
 
[1]+[1]
 
[1]+[2]+[1] new p = p[0] + p[1] / i = 0,1 需要 i in range(1)
# range(1) = 0,根据[p[i] + p[i+1]]即可实现p[0]+p[0+1]
 
[1]+[3]+[3]+[1] new p = p[0] + p[1], p[1] + p[2] /i = 0,1,2 需要 i in range(2)
[1]+[4]+[6]+[4]+[1] new p = p[0] + p[1], p[1] + p[2], p[2] + p[3] /i = 0,1,2,3 需要 i in range(3)
[1]+[5]+[10]+[10]+[5]+[1] new p = p[0] + p[1], p[1] + p[2], p[2] + p[3], p[3] + p[4] /i = 0,1,2,3,4需要 i in range(4)
</code></pre>
<p>i的规律为上一行list元素个数-1，也就是len(p) - 1<br>
至此，已经可以得出推导式：<br>
[1] + [p[i] + p[i + 1] for i in range(len(p) - 1)] + [1]</p>
<p>补全程序代码：</p>
<pre><code class="language-python">def triangles(t):
    lis = [1]
    while t:
        print(lis)
        lis = [1] + [lis[i] + lis[i + 1] for i in range(len(lis) - 1)] + [1]
        t -= 1


if __name__ == '__main__':
    triangles(10)
</code></pre>
<p>运行结果：<br>
<img src="https://image.youis.top/20200515144823.png" alt="" loading="lazy"></p>
<h1 id="例5-6-编写函数接收一个正偶数为参数输出两个素数并且这两个素数之和等于原来的正偶数-如果存在多组符合条件的素数则全部输出">例5-6  编写函数，接收一个正偶数为参数，输出两个素数，并且这两个素数之和等于原来的正偶数。如果存在多组符合条件的素数，则全部输出。</h1>
<pre><code class="language-python">def demo(n):
    def IsPrime(p):
        if p == 2:
            return True
        if p % 2 == 0:
            return False
        for i in range(3, int(p ** 0.5) + 1, 2):
            if p % i == 0:
                return False
        return True

    if isinstance(n, int) and n &gt; 0 and n % 2 == 0:
        for i in range(2, n // 2 + 1):
            if IsPrime(i) and IsPrime(n - i):
                print(i, '+', n - i, '=', n)


if __name__ == '__main__':
    demo(100)
</code></pre>
<h1 id="例5-7-编写函数计算字符串匹配的准确率">例5-7  编写函数，计算字符串匹配的准确率。</h1>
<p>以打字练习程序为例，假设origin为原始内容，userInput为用户输入的内容，下面的代码用来测试用户输入的准确率。</p>
<pre><code class="language-python">
def rate(origin, user_input):
    if not (isinstance(origin, str) and isinstance(user_input, str)):
        origin = str(origin)
        user_input = str(origin)
    right = sum((1 for o, u in zip(origin, user_input) if o == u))
    return round(right / len(origin), 2)


if __name__ == '__main__':
    print(rate(&quot;12345&quot;, &quot;1233445&quot;))
</code></pre>
<h1 id="例5-8-编写函数模拟猜数游戏">例5-8  编写函数模拟猜数游戏。</h1>
<p>系统随机产生一个数，玩家最多可以猜5次，系统会根据玩家的猜测进行提示，玩家则可以根据系统的提示对下一次的猜测进行适当调整。</p>
<pre><code class="language-python">from random import randint


def guess(maxValue=100, maxTimes=5):
    # 随机生成一个整数
    value = randint(1, maxValue)
    print(&quot;游戏开始！&quot;)
    for i in range(maxTimes):
        prompt = '你还有 %d 次机会请输入猜测的数字：' % (maxTimes - i)
        # 使用异常处理结构，防止输入不是数字的情况
        try:
            x = int(input(prompt))
        except ValueError:
            print('Must input an integer between 1 and ', maxValue)
        else:
            # 猜对了
            if x == value:
                print('恭喜你，答对啦！')
                break
            elif x &gt; value:
                print('猜大啦！')
            else:
                print('猜小了')
    else:
        # 次数用完还没猜对，游戏结束，提示正确答案
        print('游戏结束')
        print('正确答案是', value)


if __name__ == '__main__':
    guess()
</code></pre>
<h1 id="编写函数模拟报数游戏">编写函数模拟报数游戏。</h1>
<p>有n个人围成一圈，顺序编号，从第一个人开始从1到k（假设k=3）报数，报到k的人退出圈子，然后圈子缩小，从下一个人继续游戏，问最后留下的是原来的第几号。<br>
第一步：演算一下过程。j假设n=10,k=3。由于列表索引值从0开始所以第一个删除的值应该是3，索引为2 （即 k-1）<br>
删除后后面数值的索引发生改变。6的索引从 5变为4 (2+k-1)<br>
依次类推。<br>
当到删除3,6,9 剩下：  1 2 4 5 7 8 10 按理应该删除 索引为8的值。<br>
但是总长度为7。所以求余  8 % 7 = 1 。所以删除索引为1的值。<br>
具体表格演示如下：<br>
<strong>pop(2)的意思是  删除上一行索引为 2 的列。</strong></p>
<table>
<thead>
<tr>
<th>索引</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
<td style="text-align:center">8</td>
<td style="text-align:center">9</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td>pop(2)</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
<td style="text-align:center">8</td>
<td style="text-align:center">9</td>
<td style="text-align:center">10</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>pop(4)</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">7</td>
<td style="text-align:center">8</td>
<td style="text-align:center">9</td>
<td style="text-align:center">10</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>pop(6)</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">7</td>
<td style="text-align:center">8</td>
<td style="text-align:center">10</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>pop(1)</td>
<td style="text-align:center">1</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">7</td>
<td style="text-align:center">8</td>
<td style="text-align:center">10</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>pop(3)</td>
<td style="text-align:center">1</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">8</td>
<td style="text-align:center">10</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>pop(0)</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">8</td>
<td style="text-align:center">10</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>pop(2)</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">10</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>pop(1)</td>
<td style="text-align:center">4</td>
<td style="text-align:center">10</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td></td>
<td style="text-align:center">4</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>代码实现：</p>
<pre><code class="language-python">def func(n=100, k=3):
    lis = [i for i in range(1, n + 1)]
    lis_len = len(lis)
    index = (k - 1) % lis_len
    while lis_len &gt; 1:
        lis.pop(index)
        lis_len -= 1
        index = (k - 1 + index) % lis_len
        # print(lis,   index)
    print(lis[0])


if __name__ == '__main__':
    func(10, 3)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[linux获取ip地址]]></title>
        <id>https://youis.top/post/linux-huo-qu-ip-di-zhi/</id>
        <link href="https://youis.top/post/linux-huo-qu-ip-di-zhi/">
        </link>
        <updated>2020-05-10T08:21:36.000Z</updated>
        <summary type="html"><![CDATA[<p>🐶🐶🐶<br>
需要脚本获取本机ip地址<br>
默认获取第二个网卡的IP地址<br>
第一个 127.0.0.1 这个地址获取没有作用</p>
]]></summary>
        <content type="html"><![CDATA[<p>🐶🐶🐶<br>
需要脚本获取本机ip地址<br>
默认获取第二个网卡的IP地址<br>
第一个 127.0.0.1 这个地址获取没有作用</p>
<!-- more -->
<pre><code>string=`ip addr | grep  -w &quot;inet&quot; | sed -n &quot;2, 2p&quot;  | awk '{print $2}'`
</code></pre>
<p>自动获取本机ip，然后探测相同网段的ip信息。</p>
<pre><code> #!/bin/bash
 pName=$(rpm -qa | grep &quot;nmap&quot;)
 if [ $? -eq 0 ]
 then
           echo &quot;软件包nmap已经安装。&quot;
 else
            yum  install nmap -y
fi
# 获取本机ip地址
string=`ip addr | grep  -w &quot;inet&quot; | sed -n &quot;2, 2p&quot;  | awk '{print $2}'`
str=`echo ${string} | cut -d &quot;.&quot; -f 4`
ip=`echo  ${string/$str/}`
  # 探测与本机相同网段的ip
  nmap -sP ${ip}0/24 | grep &quot;192&quot; | cut -d &quot; &quot; -f 5 &gt; ipfile
  echo &quot;&quot; &gt; res
  for iplis  in `cat ipfile`
  do
     echo &quot;$iplis 的信息&quot; &gt;&gt;  res
     nmap -p1-1024  $iplis | egrep -v &quot;Starting |Nmap|Host|Not&quot; &gt;&gt; res
     echo &quot;已探测 $iplis 的简略信息 &quot;
  done
</code></pre>
<h1 id="探测ip地址">探测IP地址</h1>
<pre><code class="language-shell">#! /bin/bash
# 参数是网卡  名称
#例如：  ./test.sh  ens33
if [ &quot;$#&quot; -ne 1 ];then
	echo &quot;usage -- ./arp1.sh [interface]&quot;
	echo &quot;Example -- ./arp1.sh eth1&quot;
	exit
fi
echo &quot;&quot; &gt; mac_ip.text
interface=$1
ipprefix=`ifconfig $interface|grep &quot;netmask&quot;|awk '{print $2}'|cut -d '.' -f 1-3`
for addr in $(seq 1 1254);do
	info=$(arping -c 1 $ipprefix.$addr)
	if [ $? -eq 0 ];then
		mac=`echo $info | grep &quot;from&quot;|cut -d ' ' -f 10`
		ipaddr=`echo $info|grep &quot;from&quot;|cut -d ' ' -f 2`
		echo &quot;$mac -- $ipaddr&quot;
		echo &quot;$mac -- $ipaddr&quot; &gt;&gt; mac_ip.text
	else
		echo &quot;当前扫描的第$addr 是非活动地址!!&quot;
	fi
done
</code></pre>
]]></content>
    </entry>
</feed>